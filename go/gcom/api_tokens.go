/*
GCOM API

Grafana.com API (public).  Looking for GCOM API client packages? You can find them at [grafana-com-public-clients](https://github.com/grafana/grafana-com-public-clients) repository.  If you have any questions, please contact support in the Grafana Cloud UI.  This spec is in *Beta* stage, so use it with caution: - Not all endpoint responses are properly typed for the time being. - Some request parameter types may not be precise

API version: public
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gcom

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// TokensAPIService TokensAPI service
type TokensAPIService service

type ApiDeleteTokenRequest struct {
	ctx        context.Context
	ApiService *TokensAPIService
	id         string
	region     *string
	xRequestId *string
	orgId      *int32
}

func (r ApiDeleteTokenRequest) Region(region string) ApiDeleteTokenRequest {
	r.region = &region
	return r
}

func (r ApiDeleteTokenRequest) XRequestId(xRequestId string) ApiDeleteTokenRequest {
	r.xRequestId = &xRequestId
	return r
}

func (r ApiDeleteTokenRequest) OrgId(orgId int32) ApiDeleteTokenRequest {
	r.orgId = &orgId
	return r
}

func (r ApiDeleteTokenRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteTokenExecute(r)
}

/*
DeleteToken Delete a token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiDeleteTokenRequest
*/
func (a *TokensAPIService) DeleteToken(ctx context.Context, id string) ApiDeleteTokenRequest {
	return ApiDeleteTokenRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TokensAPIService) DeleteTokenExecute(r ApiDeleteTokenRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TokensAPIService.DeleteToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tokens/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}
	if r.xRequestId == nil {
		return localVarReturnValue, nil, reportError("xRequestId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	if r.orgId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgId", r.orgId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-request-id", r.xRequestId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v PostAllApiKeys401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PostAllApiKeys403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetInstance404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v PostAllApiKeys409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v PostAllApiKeys503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokenRequest struct {
	ctx        context.Context
	ApiService *TokensAPIService
	id         string
	region     *string
	orgId      *int32
}

func (r ApiGetTokenRequest) Region(region string) ApiGetTokenRequest {
	r.region = &region
	return r
}

func (r ApiGetTokenRequest) OrgId(orgId int32) ApiGetTokenRequest {
	r.orgId = &orgId
	return r
}

func (r ApiGetTokenRequest) Execute() (*AuthToken, *http.Response, error) {
	return r.ApiService.GetTokenExecute(r)
}

/*
GetToken Get info for a specific token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetTokenRequest
*/
func (a *TokensAPIService) GetToken(ctx context.Context, id string) ApiGetTokenRequest {
	return ApiGetTokenRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AuthToken
func (a *TokensAPIService) GetTokenExecute(r ApiGetTokenRequest) (*AuthToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TokensAPIService.GetToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tokens/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	if r.orgId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgId", r.orgId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v PostAllApiKeys401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PostAllApiKeys403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetInstance404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v PostAllApiKeys409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTokensRequest struct {
	ctx                         context.Context
	ApiService                  *TokensAPIService
	region                      *string
	accessPolicyId              *string
	accessPolicyIds             *string
	accessPolicyName            *string
	accessPolicyRealmIdentifier *string
	accessPolicyRealmType       *string
	accessPolicyStatus          *string
	expiresAfter                *string
	expiresBefore               *string
	name                        *string
	orgId                       *int32
	pageCursor                  *string
	pageSize                    *int32
}

func (r ApiGetTokensRequest) Region(region string) ApiGetTokensRequest {
	r.region = &region
	return r
}

func (r ApiGetTokensRequest) AccessPolicyId(accessPolicyId string) ApiGetTokensRequest {
	r.accessPolicyId = &accessPolicyId
	return r
}

func (r ApiGetTokensRequest) AccessPolicyIds(accessPolicyIds string) ApiGetTokensRequest {
	r.accessPolicyIds = &accessPolicyIds
	return r
}

func (r ApiGetTokensRequest) AccessPolicyName(accessPolicyName string) ApiGetTokensRequest {
	r.accessPolicyName = &accessPolicyName
	return r
}

func (r ApiGetTokensRequest) AccessPolicyRealmIdentifier(accessPolicyRealmIdentifier string) ApiGetTokensRequest {
	r.accessPolicyRealmIdentifier = &accessPolicyRealmIdentifier
	return r
}

func (r ApiGetTokensRequest) AccessPolicyRealmType(accessPolicyRealmType string) ApiGetTokensRequest {
	r.accessPolicyRealmType = &accessPolicyRealmType
	return r
}

func (r ApiGetTokensRequest) AccessPolicyStatus(accessPolicyStatus string) ApiGetTokensRequest {
	r.accessPolicyStatus = &accessPolicyStatus
	return r
}

func (r ApiGetTokensRequest) ExpiresAfter(expiresAfter string) ApiGetTokensRequest {
	r.expiresAfter = &expiresAfter
	return r
}

func (r ApiGetTokensRequest) ExpiresBefore(expiresBefore string) ApiGetTokensRequest {
	r.expiresBefore = &expiresBefore
	return r
}

func (r ApiGetTokensRequest) Name(name string) ApiGetTokensRequest {
	r.name = &name
	return r
}

func (r ApiGetTokensRequest) OrgId(orgId int32) ApiGetTokensRequest {
	r.orgId = &orgId
	return r
}

func (r ApiGetTokensRequest) PageCursor(pageCursor string) ApiGetTokensRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiGetTokensRequest) PageSize(pageSize int32) ApiGetTokensRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetTokensRequest) Execute() ([]AuthToken, *http.Response, error) {
	return r.ApiService.GetTokensExecute(r)
}

/*
GetTokens Get a list of tokens

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTokensRequest
*/
func (a *TokensAPIService) GetTokens(ctx context.Context) ApiGetTokensRequest {
	return ApiGetTokensRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []AuthToken
func (a *TokensAPIService) GetTokensExecute(r ApiGetTokensRequest) ([]AuthToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AuthToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TokensAPIService.GetTokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	if r.accessPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessPolicyId", r.accessPolicyId, "")
	}
	if r.accessPolicyIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessPolicyIds", r.accessPolicyIds, "")
	}
	if r.accessPolicyName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessPolicyName", r.accessPolicyName, "")
	}
	if r.accessPolicyRealmIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessPolicyRealmIdentifier", r.accessPolicyRealmIdentifier, "")
	}
	if r.accessPolicyRealmType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessPolicyRealmType", r.accessPolicyRealmType, "")
	}
	if r.accessPolicyStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessPolicyStatus", r.accessPolicyStatus, "")
	}
	if r.expiresAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiresAfter", r.expiresAfter, "")
	}
	if r.expiresBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "expiresBefore", r.expiresBefore, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.orgId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgId", r.orgId, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageCursor", r.pageCursor, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v PostAllApiKeys401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PostAllApiKeys403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v PostAllApiKeys409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTokenRequest struct {
	ctx              context.Context
	ApiService       *TokensAPIService
	id               string
	region           *string
	xRequestId       *string
	postTokenRequest *PostTokenRequest
	orgId            *int32
}

func (r ApiPostTokenRequest) Region(region string) ApiPostTokenRequest {
	r.region = &region
	return r
}

func (r ApiPostTokenRequest) XRequestId(xRequestId string) ApiPostTokenRequest {
	r.xRequestId = &xRequestId
	return r
}

func (r ApiPostTokenRequest) PostTokenRequest(postTokenRequest PostTokenRequest) ApiPostTokenRequest {
	r.postTokenRequest = &postTokenRequest
	return r
}

func (r ApiPostTokenRequest) OrgId(orgId int32) ApiPostTokenRequest {
	r.orgId = &orgId
	return r
}

func (r ApiPostTokenRequest) Execute() (*AuthToken, *http.Response, error) {
	return r.ApiService.PostTokenExecute(r)
}

/*
PostToken Update a token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiPostTokenRequest
*/
func (a *TokensAPIService) PostToken(ctx context.Context, id string) ApiPostTokenRequest {
	return ApiPostTokenRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return AuthToken
func (a *TokensAPIService) PostTokenExecute(r ApiPostTokenRequest) (*AuthToken, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthToken
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TokensAPIService.PostToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tokens/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}
	if r.xRequestId == nil {
		return localVarReturnValue, nil, reportError("xRequestId is required and must be specified")
	}
	if r.postTokenRequest == nil {
		return localVarReturnValue, nil, reportError("postTokenRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	if r.orgId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgId", r.orgId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-request-id", r.xRequestId, "")
	// body params
	localVarPostBody = r.postTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v PostAllApiKeys401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PostAllApiKeys403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetInstance404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v PostAllApiKeys409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v PostAllApiKeys503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTokensRequest struct {
	ctx               context.Context
	ApiService        *TokensAPIService
	region            *string
	xRequestId        *string
	postTokensRequest *PostTokensRequest
	orgId             *int32
}

func (r ApiPostTokensRequest) Region(region string) ApiPostTokensRequest {
	r.region = &region
	return r
}

func (r ApiPostTokensRequest) XRequestId(xRequestId string) ApiPostTokensRequest {
	r.xRequestId = &xRequestId
	return r
}

func (r ApiPostTokensRequest) PostTokensRequest(postTokensRequest PostTokensRequest) ApiPostTokensRequest {
	r.postTokensRequest = &postTokensRequest
	return r
}

func (r ApiPostTokensRequest) OrgId(orgId int32) ApiPostTokensRequest {
	r.orgId = &orgId
	return r
}

func (r ApiPostTokensRequest) Execute() (*AuthTokenWithSecret, *http.Response, error) {
	return r.ApiService.PostTokensExecute(r)
}

/*
PostTokens Create a new token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostTokensRequest
*/
func (a *TokensAPIService) PostTokens(ctx context.Context) ApiPostTokensRequest {
	return ApiPostTokensRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return AuthTokenWithSecret
func (a *TokensAPIService) PostTokensExecute(r ApiPostTokensRequest) (*AuthTokenWithSecret, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthTokenWithSecret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TokensAPIService.PostTokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}
	if r.xRequestId == nil {
		return localVarReturnValue, nil, reportError("xRequestId is required and must be specified")
	}
	if r.postTokensRequest == nil {
		return localVarReturnValue, nil, reportError("postTokensRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "")
	if r.orgId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orgId", r.orgId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-request-id", r.xRequestId, "")
	// body params
	localVarPostBody = r.postTokensRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v PostAllApiKeys401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v PostAllApiKeys403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v PostAllApiKeys409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v PostAllApiKeys503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
